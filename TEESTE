void dccthread_init(void (*func)(int), int param) {
	while (!dlist_empty(threads) || !dlist_empty(sleeping_threads)) {
		dccthread_t * current_thread = dlist_get_index(threads, 0);
		if (dlist_empty(threads)) {
			current_thread = dlist_get_index(sleeping_threads, 0);
		}
		
		if (current_thread->waited_thread != NULL) {
			dlist_push_right(threads, current_thread);
			dlist_pop_left(threads);
			continue;
		}

		swapcontext(&manager, current_thread->context);
		
		dlist_pop_left(threads);

		if (current_thread->yielded || current_thread->waited_thread != NULL) {
			current_thread->yielded = 0;
			dlist_push_right(threads, current_thread);
		}
	}
}

void dccthread_wakeup() {
	dccthread_t *current_thread = dlist_get_index(sleeping_threads, 0);
	dlist_pop_left(sleeping_threads);
	dlist_push_right(threads, current_thread);
}

void dccthread_sleep(struct timespec ts) {
	dlist_push_right(sleeping_threads, current_thread);

	swapcontext(current_thread->context, &manager);
}
